# 2개 이하로 다른 비트

## 문제 설명
양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.<br>v

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수<br>
예를 들어,<br><br>

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

<br>

| 수 | 비트       | 다른 비트의 개수 |
|----|------------|------------------|
| 2  | 000...0010 |                  |
| 3  | 000...0011 | 1                |

<br>

f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

<br>

| 수 | 비트       | 다른 비트의 개수 |
|----|------------|------------------|
| 7  | 000...0111 |                  |
| 8  | 000...1000 | 4                |
| 9  | 000...1001 | 3                |
| 10 | 000...1010 | 3                |
| 11 | 000...1011 | 2                |

<br>

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

<br>

### 제한사항
1 ≤ numbers의 길이 ≤ 100,000 <br>
0 ≤ numbers의 모든 수 ≤ 1015 

<br>

### 입출력 예
| numbers | result |
|---------|--------|
| [2,7]   | [3,11] |

<br>

## 나의 풀이
이번 문제는 시간 효율을 위해서는 수학적인 접근이 필요한 문제였다. <br>
만약, 주어진 문제가 짝수라면 1만 더해도 최소 값이 된다.<br>
그러나, 홀수라면 다음과 같은 공식으로 구할 수 있다. <br>
1. 홀수에서 가장 낮은 0을 1로 바꾼다.
2. 해당 0 다음의 위치인 1을 0으로 바꾼다.
3. 만약 홀수에서 0이 없다면, 1을 더한 후, 앞의 10을 냅두고 나머지를 다 1로 바꾼다.

<br>

수학적인 접근으로 충분히 해결할 수 있는 문제였다.
